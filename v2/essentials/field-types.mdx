---
title: 'Field Types'
description: 'Built-in field types and how to create custom ones'
icon: 'shapes'
---

Custom Fields v2 introduces a powerful, extensible field type system that allows developers to create their own custom field types alongside the 18 built-in types.

## Built-in Field Types

Custom Fields v2 comes with 18 pre-configured field types, each implementing a clean trait-based architecture for maximum flexibility:

| Field Type | Key | Data Type | Description |
|------------|-----|-----------|-------------|
| **Text Input** | `text` | String | Basic text input with validation |
| **Textarea** | `textarea` | Text | Multi-line text input |
| **Number** | `number` | Numeric | Numeric input with min/max validation |
| **Currency** | `currency` | Numeric | Currency formatting with locale support |
| **Link** | `link` | String | URL validation and formatting |
| **Rich Editor** | `rich-editor` | Text | WYSIWYG editor with formatting |
| **Markdown Editor** | `markdown-editor` | Text | Markdown syntax with preview |
| **Tags Input** | `tags-input` | JSON | Multiple tags with autocomplete |
| **Select** | `select` | String | Single selection dropdown |
| **Multi-Select** | `multi-select` | JSON | Multiple selections |
| **Radio** | `radio` | String | Single choice radio buttons |
| **Checkbox** | `checkbox` | Boolean | Simple true/false toggle |
| **Checkbox List** | `checkbox-list` | JSON | Multiple checkboxes |
| **Toggle** | `toggle` | Boolean | Switch-style toggle |
| **Toggle Buttons** | `toggle-buttons` | String | Button group selection |
| **Date** | `date` | Date | Date picker |
| **Date Time** | `datetime` | DateTime | Date and time picker |
| **Color Picker** | `color-picker` | String | Visual color selection |

## Creating Custom Field Types

You can extend Custom Fields by creating your own field types. This is useful when you need specialized functionality not covered by the built-in types.

### Generate a Field Type

Use the built-in command to create a new field type:

```bash
php artisan make:field-type StarRating
```

This creates a complete field type class with all necessary components.

### Field Type Structure

Custom field types extend `BaseFieldType` and use the modern `FieldTypeConfigurator` system:

```php
namespace App\Filament\CustomFieldTypes;

use Closure;
use Filament\Forms\Components\Select;
use Filament\Infolists\Components\TextEntry;
use Filament\Tables\Columns\TextColumn;
use Relaticle\CustomFields\Enums\ValidationRule;
use Relaticle\CustomFields\FieldTypes\BaseFieldType;
use Relaticle\CustomFields\FieldTypes\FieldTypeConfigurator;
use Relaticle\CustomFields\Models\CustomField;

/**
 * Star Rating field type
 */
class StarRatingFieldType extends BaseFieldType
{
    public function configure(): FieldTypeConfigurator
    {
        return FieldTypeConfigurator::numeric()
            ->key('star-rating')
            ->label('Star Rating')
            ->icon('heroicon-o-star')
            ->formComponent($this->getFormComponent())
            ->tableColumn($this->getTableColumn())
            ->infolistEntry($this->getInfolistEntry())
            ->priority(45)
            ->validationRules([
                ValidationRule::REQUIRED,
                ValidationRule::MIN,
                ValidationRule::MAX,
            ])
            ->searchable()
            ->sortable()
            ->filterable();
    }

    private function getFormComponent(): Closure
    {
        return function (CustomField $customField) {
            return Select::make($customField->getFieldName())
                ->label($customField->name)
                ->options([
                    1 => '⭐ Poor',
                    2 => '⭐⭐ Fair', 
                    3 => '⭐⭐⭐ Good',
                    4 => '⭐⭐⭐⭐ Very Good',
                    5 => '⭐⭐⭐⭐⭐ Excellent',
                ])
                ->native(false)
                ->columnSpanFull();
        };
    }

    private function getTableColumn(): Closure
    {
        return function (CustomField $customField) {
            return TextColumn::make($customField->getFieldName())
                ->label($customField->name)
                ->formatStateUsing(function ($state) {
                    if (!$state) return 'No rating';
                    
                    $rating = (int) $state;
                    return str_repeat('⭐', $rating) . " ($rating/5)";
                })
                ->html()
                ->sortable()
                ->searchable();
        };
    }

    private function getInfolistEntry(): Closure
    {
        return function (CustomField $customField) {
            return TextEntry::make($customField->getFieldName())
                ->label($customField->name)
                ->formatStateUsing(function ($state) {
                    if (!$state) return 'No rating provided';
                    
                    $rating = (int) $state;
                    $labels = [1 => 'Poor', 2 => 'Fair', 3 => 'Good', 4 => 'Very Good', 5 => 'Excellent'];
                    
                    return str_repeat('⭐', $rating) . " - {$labels[$rating]} ($rating/5)";
                })
                ->html();
        };
    }
}
```

### Register Your Field Type

There are two ways to register your custom field type:

#### Option 1: Register in Filament Panel Provider (Recommended)

```php
namespace App\Providers\Filament;

use App\Filament\CustomFieldTypes\FieldTypes\StarRatingFieldType;
use Relaticle\CustomFields\CustomFieldsPlugin;

class AdminPanelProvider extends PanelProvider
{
    public function panel(Panel $panel): Panel
    {
        return $panel
            ->plugins([
                CustomFieldsPlugin::make()->registerFieldTypes([
                    StarRatingFieldType::class,
                ]),
                // Other plugins...
            ]);
    }
}
```

#### Option 2: Register in Service Provider

```php
namespace App\Providers;

use App\Filament\CustomFieldTypes\FieldTypes\StarRatingFieldType;
use Relaticle\CustomFields\Facades\CustomFieldsType;

class AppServiceProvider extends ServiceProvider
{
    public function boot(): void
    {
        CustomFieldsType::register([
            StarRatingFieldType::class,
        ]);
    }
}
```

## Field Type Configurators

The `FieldTypeConfigurator` system provides a fluent API for defining field types. Choose the appropriate configurator based on your field's data type:

### Available Configurators

```php
// Text-based fields
FieldTypeConfigurator::text()     // For STRING data type
FieldTypeConfigurator::string()   // Alias for text()

// Numeric fields  
FieldTypeConfigurator::numeric()  // For NUMERIC data type
FieldTypeConfigurator::float()    // For FLOAT data type

// Date/time fields
FieldTypeConfigurator::date()     // For DATE data type
FieldTypeConfigurator::dateTime() // For DATE_TIME data type

// Boolean fields
FieldTypeConfigurator::boolean()  // For BOOLEAN data type

// Choice fields
FieldTypeConfigurator::singleChoice() // For SINGLE_CHOICE data type
FieldTypeConfigurator::multiChoice()  // For MULTI_CHOICE data type
```

### Component Types

Field types support two approaches for defining components:

#### 1. Class-Based Components (Simple)

For simple fields, reference Filament component classes directly:

```php
->formComponent(TextInput::class)
->tableColumn(TextColumn::class)
->infolistEntry(TextEntry::class)
```

#### 2. Closure-Based Components (Flexible)

For complex fields, use closures that return configured components:

```php
->formComponent($this->getFormComponent())
->tableColumn($this->getTableColumn()) 
->infolistEntry($this->getInfolistEntry())
```

### Field Capabilities

Configure what your field type supports:

```php
->searchable()        // Enable table searching
->sortable()          // Enable table sorting
->filterable()        // Add table filter support
->encryptable()       // Allow field encryption
```

### Choice Field Option Handling

Choice fields support different option sources:

#### `->withoutUserOptions()`
**Field type provides all options - no user customization**

```php
FieldTypeConfigurator::singleChoice() // or multiChoice()
    ->withoutUserOptions() // Field controls options
    ->formComponent($this->getFormComponent())
```

- **Effect**: Disables "Options" tab when creating fields
- **Use Cases**: Built-in options, database lookups, fixed choices

#### Default Behavior
**Users define their own options**

```php
FieldTypeConfigurator::singleChoice() // or multiChoice()
    // No ->withoutUserOptions() call
    ->formComponent($this->getFormComponent())
```

- **Effect**: Shows "Options" tab when creating fields
- **Use Cases**: Custom categories, user-specific selections

#### `->withArbitraryValues()`
**Accept both predefined and new typed values**

```php
FieldTypeConfigurator::multiChoice()
    ->withArbitraryValues() // Accept new values
    ->formComponent($this->getFormComponent())
```

- **Use Cases**: Tag inputs, flexible categorization

### Data Types

Custom Fields supports these data types, each optimized for specific use cases:

```php
enum FieldDataType: string
{
    case STRING = 'string';          // Short text, URLs, identifiers
    case TEXT = 'text';              // Long text, rich content, markdown
    case NUMERIC = 'numeric';        // Integers, counts
    case FLOAT = 'float';            // Decimal numbers, currency
    case DATE = 'date';              // Date only
    case DATE_TIME = 'date_time';    // Date with time
    case BOOLEAN = 'boolean';        // True/false, checkboxes, toggles
    case SINGLE_CHOICE = 'single_choice';  // Select, radio buttons
    case MULTI_CHOICE = 'multi_choice';    // Multi-select, checkbox lists, tags
}
```

Each data type provides:
- **Storage optimization** - Proper database column types and constraints
- **Validation compatibility** - Specific validation rules that make sense for the data type
- **Conditional visibility** - Compatible operators for visibility conditions
- **Import/export handling** - Automatic value transformation during CSV operations

Choose the appropriate data type based on how your field's values should be stored and handled.

### Field Type Priority

Field types are ordered by priority (lower numbers appear first):

- **10-20**: Common text fields
- **30-40**: Selection fields
- **50-60**: Specialized fields
- **70+**: Advanced fields

## Best Practices

1. **Use Existing Filament Components**: Build on Filament's components like `Select`, `TextInput`, etc.
2. **Follow Naming Conventions**: Use kebab-case for keys (e.g., `star-rating`, `country-select`)
3. **Use the Right Configurator**: Choose the configurator that matches your data type
4. **Use Closures for Flexibility**: For complex components, use closure-based definitions
5. **Test Your Components**: Ensure your field type works in forms, tables, and infolists
6. **Consider Validation**: Only allow validation rules that make sense for your field type

## Examples

### Built-in Options (withoutUserOptions)

Field type provides predefined options:

```php
public function configure(): FieldTypeConfigurator
{
    return FieldTypeConfigurator::singleChoice()
        ->key('priority-level')
        ->label('Priority Level')
        ->icon('heroicon-o-flag')
        ->withoutUserOptions() // Field provides options
        ->formComponent($this->getFormComponent())
        ->priority(50);
}

private function getFormComponent(): Closure
{
    return function (CustomField $customField) {
        return Select::make($customField->getFieldName())
            ->label($customField->name)
            ->options([
                1 => 'Low',
                2 => 'Medium', 
                3 => 'High',
                4 => 'Critical',
            ]);
    };
}
```

### User-Defined Options (default)

Users define their own options when creating fields:

```php
public function configure(): FieldTypeConfigurator
{
    return FieldTypeConfigurator::multiChoice()
        ->key('product-tags')
        ->label('Product Tags')
        ->icon('heroicon-o-tag')
        // No ->withoutUserOptions() - users define options
        ->formComponent($this->getFormComponent())
        ->priority(50);
}

private function getFormComponent(): Closure
{
    return function (CustomField $customField) {
        return CheckboxList::make($customField->getFieldName())
            ->label($customField->name);
            // Options automatically applied by the system
    };
}
```

### Dynamic Database Options

Field with database-driven options:

```php
public function configure(): FieldTypeConfigurator
{
    return FieldTypeConfigurator::singleChoice()
        ->key('customer-selector')
        ->label('Customer Selector')
        ->icon('heroicon-o-users')
        ->withoutUserOptions() // Field provides dynamic options
        ->formComponent($this->getFormComponent())
        ->priority(50);
}

private function getFormComponent(): Closure
{
    return function (CustomField $customField) {
        return Select::make($customField->getFieldName())
            ->label($customField->name)
            ->searchable()
            ->getSearchResultsUsing(fn (string $search): array => 
                Customer::where('name', 'like', "%{$search}%")
                    ->limit(50)
                    ->pluck('name', 'id')
                    ->toArray()
            )
            ->getOptionLabelUsing(fn ($value): ?string => 
                Customer::find($value)?->name
            );
    };
}
```

## Troubleshooting

### Field Type Not Appearing

If your custom field type doesn't appear in the dropdown:

1. Ensure your field type class extends `BaseFieldType`
2. Verify the field type is registered correctly
3. Clear Laravel's cache: `php artisan cache:clear`
4. Check that all required configuration methods return valid values

### Components Not Rendering

If your components don't render correctly:

1. Verify you're using `$customField->getFieldName()` for field names
2. For closure-based components, ensure closures return valid Filament components
3. Test with simple components first before adding complexity
4. Check that you're importing all necessary Filament component classes

Your custom field type will now appear in the field type dropdown when creating new custom fields!